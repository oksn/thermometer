C51 COMPILER V7.06   SHT11                                                                 02/18/2020 17:02:25 PAGE 1   


C51 COMPILER V7.06, COMPILATION OF MODULE SHT11
OBJECT MODULE PLACED IN SHT11.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE SHT11.C COMPACT BROWSE DEBUG OBJECTEXTEND

stmt level    source

   1          /****************************************Copyright (c)**************************************************
   2          **
   3          **
   4          **
   5          **--------------文件信息--------------------------------------------------------------------------------
   6          **文   件   名: sht11app.c
   7          **创   建   人:
   8          **最后修改日期:
   9          **描        述:
  10          **
  11          **--------------历史版本信息----------------------------------------------------------------------------
  12          ** 创建人:
  13          ** 版  本: v1.01
  14          ** 日　期:
  15          ** 描　述: 原始版本
  16          **
  17          **--------------当前版本修订------------------------------------------------------------------------------
  18          ** 修改人:
  19          ** 日　期:
  20          ** 描　述:
  21          **
  22          **------------------------------------------------------------------------------------------------------
  23          ********************************************************************************************************/
  24          #define _SHT11APP_GLOBAL_
  25          #include  "config.h"
  26          #include  "sht11.h"
  27          #include  "math.h"
  28          /***********************************************************************************
  29          Project: SHT11 demo program (V2.0)
  30          Filename: SHT11.c
  31          Prozessor: 80C51 family
  32          Compiler: Keil Version 6.14
  33          Autor: MST
  34          Copyrigth: (c) Sensirion AG
  35          ***********************************************************************************/
  36          sbit DATA = P1 ^ 2;
  37          sbit  SCK = P1 ^ 1;
  38          #define noACK 0
  39          #define ACK 1
  40          //adr command r/w
  41          #define STATUS_REG_W 0x06 //000 0011 0
  42          #define STATUS_REG_R 0x07 //000 0011 1
  43          #define MEASURE_TEMP 0x03 //000 0001 1
  44          #define MEASURE_HUMI 0x05 //000 0010 1
  45          #define RESET 0x1e //000 1111 0
  46          typedef union
  47          {
  48              unsigned int i;
  49              float f;
  50          } value;
  51          //----------------------------------------------------------------------------------
  52          // modul-var
  53          //----------------------------------------------------------------------------------
  54          enum {TEMP, HUMI};
  55          extern float  xdata RealHumiVal;
C51 COMPILER V7.06   SHT11                                                                 02/18/2020 17:02:25 PAGE 2   

  56          extern float  xdata RealTemVal;
  57          //----------------------------------------------------------------------------------
  58          char s_write_byte ( unsigned char value )
  59          //----------------------------------------------------------------------------------
  60          // writes a byte on the Sensibus and checks the acknowledge
  61          {
  62   1          unsigned char  xdata i, error = 0;
  63   1          for ( i = 0x80; i > 0; i /= 2 ) //shift bit for masking
  64   1          {
  65   2              if ( i & value )
  66   2              {
  67   3                  DATA = 1;  //masking value with i , write to SENSI-BUS
  68   3              }
  69   2              else
  70   2              {
  71   3                  DATA = 0;
  72   3              }
  73   2              SCK = 1; //clk for SENSI-BUS
  74   2              _nop_();
  75   2              _nop_();
  76   2              _nop_(); //pulswith approx. 5 us
  77   2              SCK = 0;
  78   2          }
  79   1          DATA = 1; //release DATA-line
  80   1          SCK = 1; //clk #9 for ack
  81   1          error = DATA; //check ack (DATA will be pulled down by SHT11)
  82   1          SCK = 0;
  83   1          return error; //error=1 in case of no acknowledge
  84   1      }
  85          //----------------------------------------------------------------------------------
  86          char s_read_byte ( unsigned char ack )
  87          //----------------------------------------------------------------------------------
  88          // reads a byte form the Sensibus and gives an acknowledge in case of "ack=1"
  89          {
  90   1          unsigned char  xdata i, val = 0;
  91   1          DATA = 1; //release DATA-line
  92   1          for ( i = 0x80; i > 0; i /= 2 ) //shift bit for masking
  93   1          {
  94   2              SCK = 1; //clk for SENSI-BUS
  95   2              if ( DATA )
  96   2              {
  97   3                  val = ( val | i ); //read bit
  98   3              }
  99   2              SCK = 0;
 100   2          }
 101   1          DATA = !ack; //in case of "ack==1" pull down DATA-Line
 102   1          SCK = 1; //clk #9 for ack
 103   1          _nop_();
 104   1          _nop_();
 105   1          _nop_(); //pulswith approx. 5 us
 106   1          SCK = 0;
 107   1          DATA = 1; //release DATA-line
 108   1          return val;
 109   1      }
 110          //----------------------------------------------------------------------------------
 111          void s_transstart ( void )
 112          //----------------------------------------------------------------------------------
 113          // generates a transmission start
 114          // _____ ________
 115          // DATA: |_______|
 116          // ___ ___
 117          // SCK : ___| |___| |______
C51 COMPILER V7.06   SHT11                                                                 02/18/2020 17:02:25 PAGE 3   

 118          {
 119   1          DATA = 1;
 120   1          SCK = 0; //Initial state
 121   1          _nop_();
 122   1          SCK = 1;
 123   1          _nop_();
 124   1          DATA = 0;
 125   1          _nop_();
 126   1          SCK = 0;
 127   1          _nop_();
 128   1          _nop_();
 129   1          _nop_();
 130   1          SCK = 1;
 131   1          _nop_();
 132   1          DATA = 1;
 133   1          _nop_();
 134   1          SCK = 0;
 135   1      }
 136          //----------------------------------------------------------------------------------
 137          void s_connectionreset ( void )
 138          //----------------------------------------------------------------------------------
 139          // communication reset: DATA-line=1 and at least 9 SCK cycles followed by transstart
 140          // _____________________________________________________ ________
 141          // DATA: |_______|
 142          // _ _ _ _ _ _ _ _ _ ___ ___
 143          // SCK : __| |__| |__| |__| |__| |__| |__| |__| |__| |______| |___| |______
 144          {
 145   1          unsigned char xdata i;
 146   1          DATA = 1;
 147   1          SCK = 0; //Initial state
 148   1          for ( i = 0; i < 9; i++ ) //9 SCK cycles
 149   1          {
 150   2              SCK = 1;
 151   2              SCK = 0;
 152   2          }
 153   1          s_transstart(); //transmission start
 154   1      }
 155          /*
 156          //----------------------------------------------------------------------------------
 157          char s_softreset(void)
 158          //----------------------------------------------------------------------------------
 159          // resets the sensor by a softreset
 160          {
 161              unsigned char  xdata error=0;
 162              s_connectionreset(); //reset communication
 163              error+=s_write_byte(RESET); //send RESET-command to sensor
 164              return error; //error=1 in case of no response form the sensor
 165          }
 166          */
 167          /*
 168          //----------------------------------------------------------------------------------
 169          char s_read_statusreg(unsigned char *p_value, unsigned char *p_checksum)
 170          //----------------------------------------------------------------------------------
 171          // reads the status register with checksum (8-bit)
 172          {
 173              unsigned char  xdata error=0;
 174              s_transstart(); //transmission start
 175              error=s_write_byte(STATUS_REG_R); //send command to sensor
 176              *p_value=s_read_byte(ACK); //read status register (8-bit)
 177              *p_checksum=s_read_byte(noACK); //read checksum (8-bit)
 178              return error; //error=1 in case of no response form the sensor
 179          }
C51 COMPILER V7.06   SHT11                                                                 02/18/2020 17:02:25 PAGE 4   

 180          */
 181          /*
 182          //----------------------------------------------------------------------------------
 183          char s_write_statusreg(unsigned char *p_value)
 184          //----------------------------------------------------------------------------------
 185          // writes the status register with checksum (8-bit)
 186          {
 187              unsigned char error=0;
 188              s_transstart(); //transmission start
 189              error+=s_write_byte(STATUS_REG_W);//send command to sensor
 190              error+=s_write_byte(*p_value); //send value of status register
 191              return error; //error>=1 in case of no response form the sensor
 192          }
 193          */
 194          //----------------------------------------------------------------------------------
 195          char s_measure ( unsigned char *p_value, unsigned char *p_checksum, unsigned char mode )
 196          //----------------------------------------------------------------------------------
 197          // makes a measurement (humidity/temperature) with checksum
 198          {
 199   1          unsigned  xdata error = 0;
 200   1          unsigned int  xdata i;
 201   1          s_transstart(); //transmission start
 202   1          switch ( mode )
 203   1          {
 204   2                  //send command to sensor
 205   2              case TEMP :
 206   2                  error += s_write_byte ( MEASURE_TEMP );
 207   2                  break;
 208   2              case HUMI :
 209   2                  error += s_write_byte ( MEASURE_HUMI );
 210   2                  break;
 211   2              default :
 212   2                  break;
 213   2          }
 214   1          for ( i = 0; i < 65535; i++ ) if ( DATA == 0 )
 215   1              {
 216   2                  break;    //wait until sensor has finished the measurement
 217   2              }
 218   1          if ( DATA )
 219   1          {
 220   2              error += 1;  // or timeout (~2 sec.) is reached
 221   2          }
 222   1          * ( p_value ) = s_read_byte ( ACK ); //read the first byte (MSB)
 223   1          * ( p_value + 1 ) = s_read_byte ( ACK ); //read the second byte (LSB)
 224   1          *p_checksum = s_read_byte ( noACK ); //read checksum
 225   1          return error;
 226   1      }
 227          //----------------------------------------------------------------------------------------
 228          void calc_sth11 ( float *p_humidity , float *p_temperature )
 229          //----------------------------------------------------------------------------------------
 230          // calculates temperature [C] and humidity [%RH]
 231          // input : humi [Ticks] (12 bit)
 232          // temp [Ticks] (14 bit)
 233          // output: humi [%RH]
 234          // temp [C]
 235          {
 236   1          code float C1 = -4.0; // for 12 Bit
 237   1          code float C2 = 0.0405; // for 12 Bit
 238   1          code float C3 = -0.0000028; // for 12 Bit
 239   1          code float T1 = 0.01; // for 14 Bit @ 5V
 240   1          code float T2 = 0.00008; // for 14 Bit @ 5V
 241   1          float xdata rh = *p_humidity; // rh: Humidity [Ticks] 12 Bit
C51 COMPILER V7.06   SHT11                                                                 02/18/2020 17:02:25 PAGE 5   

 242   1          float xdata t = *p_temperature; // t: Temperature [Ticks] 14 Bit
 243   1          float xdata rh_lin; // rh_lin: Humidity linear
 244   1          float xdata rh_true; // rh_true: Temperature compensated humidity
 245   1          float xdata t_C; // t_C : Temperature [C]
 246   1          t_C = t * 0.01 - 40; //calc. Temperature from ticks to [C]
 247   1          rh_lin = C3 * rh * rh + C2 * rh + C1; //calc. Humidity from ticks to [%RH]
 248   1          rh_true = ( t_C - 25 ) * ( T1 + T2 * rh ) + rh_lin; //calc. Temperature compensated humidity [%RH]
 249   1          if ( rh_true > 100 )
 250   1          {
 251   2              rh_true = 100;  //cut if the value is outside of
 252   2          }
 253   1          if ( rh_true < 0.1 )
 254   1          {
 255   2              rh_true = 0.1;  //the physical possible range
 256   2          }
 257   1          *p_temperature = t_C; //return temperature [C]
 258   1          *p_humidity = rh_true; //return humidity[%RH]
 259   1      }
 260          //--------------------------------------------------------------------
 261          float calc_dewpoint ( float h, float t )
 262          //--------------------------------------------------------------------
 263          // calculates dew point
 264          // input: humidity [%RH], temperature [C]
 265          // output: dew point [C]
 266          {
 267   1          float xdata logEx, dew_point ;
 268   1          logEx = 0.66077 + 7.5 * t / ( 237.3 + t ) + ( log10 ( h ) - 2 ) ;
 269   1          dew_point = ( ( logEx - 0.66077 ) * 237.3 ) / ( 0.66077 + 7.5 - logEx ) ;
 270   1          return dew_point;
 271   1      }
 272          //----------------------------------------------------------------------------------
 273          void GetSht11Value ( void )
 274          //----------------------------------------------------------------------------------
 275          // sample program that shows how to use SHT11 functions
 276          // 1. connection reset
 277          // 2. measure humidity [ticks](12 bit) and temperature [ticks](14 bit)
 278          // 3. calculate humidity [%RH] and temperature [C]
 279          // 4. calculate dew point [C]
 280          // 5. print temperature, humidity, dew point
 281          {
 282   1          value xdata humi_val, temp_val;
 283   1          float xdata dew_point;
 284   1          unsigned char xdata error, checksum;
 285   1      //  unsigned int  xdata i;
 286   1          s_connectionreset();
 287   1          error = 0;
 288   1          error += s_measure ( ( unsigned char* ) &humi_val.i, &checksum, HUMI ); //measure humidity
 289   1          error += s_measure ( ( unsigned char* ) &temp_val.i, &checksum, TEMP ); //measure temperature
 290   1          if ( error != 0 )
 291   1          {
 292   2              s_connectionreset(); //in case of an error: connection reset
 293   2          }
 294   1          else
 295   1          {
 296   2              humi_val.f = ( float ) humi_val.i; //converts integer to float
 297   2              temp_val.f = ( float ) temp_val.i; //converts integer to float
 298   2              calc_sth11 ( &humi_val.f, &temp_val.f ); //calculate humidity, temperature
 299   2              dew_point = calc_dewpoint ( humi_val.f, temp_val.f ); //calculate dew point
 300   2              RealHumiVal = humi_val.f;
 301   2              RealTemVal = temp_val.f;
 302   2              //  RealHumiVal = 69.0;
 303   2              // RealTemVal = 35.1;
C51 COMPILER V7.06   SHT11                                                                 02/18/2020 17:02:25 PAGE 6   

 304   2          }
 305   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1213    ----
   CONSTANT SIZE    =     20    ----
   XDATA SIZE       =   ----      51
   PDATA SIZE       =      1      21
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
