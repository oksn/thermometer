C51 COMPILER V7.06   REGISTER                                                              01/16/2017 13:25:52 PAGE 1   


C51 COMPILER V7.06, COMPILATION OF MODULE REGISTER
OBJECT MODULE PLACED IN register.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE lib\register.c LARGE BROWSE INCDIR(.\lib) DEBUG OBJECTEXTEND PRINT(.\regist
                    -er.lst) TABS(2) OBJECT(register.obj)

stmt level    source

   1          //-------------------------------------------------------------------
   2          //工 程 名：智能控制系统
   3          //功    能：系统寄存器定义
   4          //设    计：rtx51
   5          //日    期：2009/09/27
   6          //说    明：http://shop36037744.taobao.com
   7          //修    改：
   8          //          无
   9          //-------------------------------------------------------------------
  10          //寄 存 器  地址  长度(字)
  11          //AI        0     4
  12          //DI        4     1
  13          //DQ        6     1
  14          //开启指令  10    20
  15          //关闭指令  30    20
  16          //查询指令  50    20
  17          //数字报警1 70    20
  18          //数字报警2 90    20
  19          //数字报警3 110   20
  20          //数字报警4 130   20
  21          //数字报警5 150   20
  22          //数字报警6 170   20
  23          //数字报警7 190   20
  24          //数字报警8 210   20
  25          //-------------------------------------------------------------------
  26          #include "register.h"
  27          #include "eeprom.h"
*** WARNING C318 IN LINE 27 OF lib\register.c: can't open file 'eeprom.h'
  28          idata uint16 I[1] = {0};
  29          idata uint16 Q[1] = {0};
  30          idata uint16 AI[4];
  31          idata char cmd_sms_buf[25] = {0};
  32          void register_init ( void )
  33          {
  34   1          register_from_eeprom();
  35   1      }
  36          //---------------------------------------------------------
  37          //函数功能：register_readbytes
  38          //输入参数：
  39          //          pkt   , 数据指针
  40          //          addr  , 变量地址
  41          //          len   , 变量个数
  42          //返 回 值：
  43          //          0, 操作成功
  44          //          1, 操作失败
  45          //修改记录：无
  46          //---------------------------------------------------------
  47          int8 register_readbytes ( uint8* pkt, uint16 addr, uint8 len )
  48          {
  49   1          uint8 i;
  50   1          if ( ( addr == 0 ) && ( len == 7 ) )        // AI DI DQ
  51   1          {
  52   2              for ( i = 0; i < 4; i++ )
  53   2              {
C51 COMPILER V7.06   REGISTER                                                              01/16/2017 13:25:52 PAGE 2   

  54   3                  pkt[i*2 + 0] = AI[i] >> 8;
  55   3                  pkt[i*2 + 1] = AI[i];
  56   3              }
  57   2              pkt[8] = I[0] >> 8;
  58   2              pkt[9] = I[0];
  59   2              pkt[10] = Q[0] >> 8;
  60   2              pkt[11] = Q[0];
  61   2              pkt[12] = 0;
  62   2              pkt[13] = VERTION;
  63   2              return ( 0 );
  64   2          }
  65   1          for ( i = 0; i < 24; i++ )                                      // 继电器相关命令处理
  66   1          {
  67   2              if ( ( addr >= ( 10 + 20 * i ) ) && ( ( addr + len ) <= ( 30 + 20 * i ) ) ) // 读启动命令
  68   2              {
  69   3                  eeprom_read_data ( 20 * i, pkt, 20 );
*** WARNING C206 IN LINE 69 OF LIB\REGISTER.C: 'eeprom_read_data': missing function-prototype
*** ERROR C267 IN LINE 69 OF LIB\REGISTER.C: 'eeprom_read_data': requires ANSI-style prototype
  70   3                  return 0;
  71   3              }
  72   2          }
  73   1          for ( i = 0; i < 8; i++ )                                       // 数字报警信息
  74   1          {
  75   2              if ( ( addr >= ( 522 + 20 * i ) ) && ( ( addr + len ) <= ( 542 + 20 * i ) ) )
  76   2              {
  77   3                  eeprom_read_data ( ( 512 + 20 * i ), pkt, 20 );
  78   3                  return 0;
  79   3              }
  80   2          }
  81   1          for ( i = 0; i < 3; i++ )                                       // 手机号码
  82   1          {
  83   2              if ( ( addr >= ( 710 + 20 * i ) ) && ( ( addr + len ) <= ( 730 + 20 * i ) ) )
  84   2              {
  85   3                  eeprom_read_data ( ( 710 + 20 * i ), pkt, 20 );
  86   3                  return 0;
  87   3              }
  88   2          }
  89   1          for ( i = 0; i < 5; i++ )                                       // 模拟信息查询命令
  90   1          {
  91   2              if ( ( addr >= ( 770 + 20 * i ) ) && ( ( addr + len ) <= ( 790 + 20 * i ) ) )
  92   2              {
  93   3                  eeprom_read_data ( ( 770 + 20 * i ), pkt, 20 );
  94   3                  return 0;
  95   3              }
  96   2          }
  97   1          if ( ( addr == 900 ) && ( len == 1 ) )
  98   1          {
  99   2              eeprom_read_data ( 900, pkt, 1 );
 100   2              return 0;
 101   2          }
 102   1          return 0;
 103   1      }
 104          void register_to_eeprom ( void )
 105          {
 106   1          uint8 i;
 107   1          eeprom_erase ( 0 );
 108   1          for ( i = 0; i < 30; i++ )
 109   1          {
 110   2          }
 111   1      }
 112          void register_from_eeprom ( void )
 113          {
C51 COMPILER V7.06   REGISTER                                                              01/16/2017 13:25:52 PAGE 3   

 114   1          int i, j;
 115   1          printf ( "the mcu eeprom cmd is:\n" );
 116   1          for ( j = 0; j < 24; j++ )
 117   1          {
 118   2              for ( i = 0; i < 20; i++ )
 119   2              {
 120   3                  cmd_sms_buf[i] = eeprom_read ( 20 * j + i );
 121   3              }
 122   2              if ( ( j % 3 ) == 0 )
 123   2              {
 124   3                  printf ( "继电器%d------------------------------\n", j / 3 + 1 );
 125   3                  printf ( "open cmd   :[%s]\n", cmd_sms_buf );
 126   3              }
 127   2              else if ( ( j % 3 ) == 1 )
 128   2              {
 129   3                  printf ( "close cmd  :[%s]\n", cmd_sms_buf );
 130   3              }
 131   2              else
 132   2              {
 133   3                  printf ( "res   cmd  :[%s]\n", cmd_sms_buf );
 134   3              }
 135   2          }
 136   1          for ( i = 0; i < 20; i++ )
 137   1          {
 138   2              cmd_sms_buf[i] = eeprom_read ( 480 + i );
 139   2          }
 140   1          printf ( "all open cmd:[%s]\n", cmd_sms_buf );
 141   1          memset ( cmd_sms_buf, 0, sizeof ( cmd_sms_buf ) );
 142   1          for ( i = 0; i < 12; i++ )
 143   1          {
 144   2              cmd_sms_buf[i] = eeprom_read ( 500 + i );
 145   2          }
 146   1          printf ( "all close cmd:[%s]\n", cmd_sms_buf );
 147   1          for ( i = 0; i < 8; i++ )
 148   1          {
 149   2              for ( j = 0; j < 20; j++ )
 150   2              {
 151   3                  cmd_sms_buf[j] = eeprom_read ( 512 + 20 * i + j );
 152   3              }
 153   2              printf ( "alram msg  :[%s]\n", cmd_sms_buf );
 154   2          }
 155   1          for ( i = 0; i < 5; i++ )
 156   1          {
 157   2              eeprom_read_data ( 770 + 20 * i, cmd_sms_buf, 20 );
 158   2              printf ( "adc check cmd:[%s]\n", cmd_sms_buf );
 159   2          }
 160   1          for ( i = 0; i < 3; i++ )
 161   1          {
 162   2              eeprom_read_data ( 710 + 20 * i, cmd_sms_buf, 20 );
 163   2              printf ( "phone number :[%s]\n", cmd_sms_buf );
 164   2          }
 165   1          i = eeprom_read ( 900 );
 166   1          printf ( "device addr is %d\n", i );
 167   1      }
 168          //---------------------------------------------------------
 169          //函数功能：register_writebytes
 170          //输入参数：
 171          //          pkt   , 数据指针
 172          //          addr  , 变量地址
 173          //          len   , 变量个数
 174          //返 回 值：
 175          //          0, 操作成功
C51 COMPILER V7.06   REGISTER                                                              01/16/2017 13:25:52 PAGE 4   

 176          //          1, 操作失败
 177          //修改记录：无
 178          //---------------------------------------------------------
 179          int8 register_writebytes ( uint8* pkt, uint16 addr, uint8 len )
 180          {
 181   1          uint16 i, j;
 182   1          if ( ( addr == 5 ) && ( len ) == 1 )                // 写继电器
 183   1          {
 184   2              Q[0] = pkt[0] << 8 | pkt[1];
 185   2              return 0;
 186   2          }
 187   1          for ( i = 0; i < 24; i++ )                                      // 继电器相关命令处理
 188   1          {
 189   2              if ( ( addr >= ( 10 + 20 * i ) ) && ( ( addr + len ) <= ( 30 + 20 * i ) ) ) // 写启动命令
 190   2              {
 191   3                  if ( i == 0 )
 192   3                  {
 193   4                      eeprom_erase ( 0 );
 194   4                  }
 195   3                  memset ( cmd_sms_buf, 0, sizeof ( cmd_sms_buf ) );
 196   3                  memcpy ( cmd_sms_buf, pkt, len * 2 );
 197   3                  for ( j = 0; j < 20; j++ )
 198   3                  {
 199   4                      eeprom_write ( ( 20 * i + j ), cmd_sms_buf[j] );
 200   4                  }
 201   3                  return 0;
 202   3              }
 203   2          }
 204   1          if ( ( addr >= 490 ) && ( ( addr + len ) <= 510 ) )             // 全开指令
 205   1          {
 206   2              memset ( cmd_sms_buf, 0, sizeof ( cmd_sms_buf ) );
 207   2              memcpy ( cmd_sms_buf, pkt, len * 2 );
 208   2              for ( i = 0; i < 20; i++ )
 209   2              {
 210   3                  eeprom_write ( ( 480 + i ), cmd_sms_buf[i] );
 211   3              }
 212   2              return 0;
 213   2          }
 214   1          if ( ( addr >= 510 ) && ( ( addr + len ) < 522 ) )              // 全关指令
 215   1          {
 216   2              memset ( cmd_sms_buf, 0, sizeof ( cmd_sms_buf ) );
 217   2              memcpy ( cmd_sms_buf, pkt, len * 2 );
 218   2              for ( i = 0; i < 12; i++ )
 219   2              {
 220   3                  eeprom_write ( ( 500 + i ), cmd_sms_buf[i] );
 221   3              }
 222   2              return 0;
 223   2          }
 224   1          for ( i = 0; i < 8; i++ )                                       // 报警相关命令处理
 225   1          {
 226   2              if ( ( addr >= ( 522 + 20 * i ) ) && ( ( addr + len ) <= ( 542 + 20 * i ) ) )
 227   2              {
 228   3                  if ( i == 0 )
 229   3                  {
 230   4                      eeprom_erase ( 512 );
 231   4                  }
 232   3                  memset ( cmd_sms_buf, 0, sizeof ( cmd_sms_buf ) );
 233   3                  memcpy ( cmd_sms_buf, pkt, len * 2 );
 234   3                  for ( j = 0; j < 20; j++ )
 235   3                  {
 236   4                      eeprom_write ( ( 512 + 20 * i + j ), cmd_sms_buf[j] );
 237   4                  }
C51 COMPILER V7.06   REGISTER                                                              01/16/2017 13:25:52 PAGE 5   

 238   3                  return 0;
 239   3              }
 240   2          }
 241   1          for ( i = 0; i < 3; i++ )                                       // 报警手机号码
 242   1          {
 243   2              if ( ( addr >= ( 710 + 20 * i ) ) && ( ( addr + len ) <= ( 730 + 20 * i ) ) )
 244   2              {
 245   3                  memset ( cmd_sms_buf, 0, sizeof ( cmd_sms_buf ) );
 246   3                  memcpy ( cmd_sms_buf, pkt, len * 2 );
 247   3                  for ( j = 0; j < 20; j++ )
 248   3                  {
 249   4                      eeprom_write ( ( 710 + 20 * i + j ), cmd_sms_buf[j] );
 250   4                  }
 251   3                  return 0;
 252   3              }
 253   2          }
 254   1          for ( i = 0; i < 5; i++ )                                       // 模拟量指令
 255   1          {
 256   2              if ( ( addr >= ( 770 + 20 * i ) ) && ( ( addr + len ) <= ( 790 + 20 * i ) ) )
 257   2              {
 258   3                  memset ( cmd_sms_buf, 0, sizeof ( cmd_sms_buf ) );
 259   3                  memcpy ( cmd_sms_buf, pkt, len * 2 );
 260   3                  for ( j = 0; j < 20; j++ )
 261   3                  {
 262   4                      eeprom_write ( ( 770 + 20 * i + j ), cmd_sms_buf[j] );
 263   4                  }
 264   3                  return 0;
 265   3              }
 266   2          }
 267   1          if ( ( addr == 900 ) && ( len == 1 ) )
 268   1          {
 269   2              eeprom_write ( 900, pkt[1] );
 270   2              return 0;
 271   2          }
 272   1          return 1;
 273   1      }
 274          int8 register_chk_adr ( uint8 addr )
 275          {
 276   1          uint8 soft_addr;
 277   1          soft_addr = eeprom_read ( 900 );
 278   1          if ( ( addr == 1 ) || ( addr == soft_addr ) )
 279   1          {
 280   2              return 0;
 281   2          }
 282   1          else
 283   1          {
 284   2              return 1;
 285   2          }
 286   1      }

C51 COMPILATION COMPLETE.  2 WARNING(S),  1 ERROR(S)
